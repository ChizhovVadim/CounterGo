package eval

import (
	"math"

	. "github.com/ChizhovVadim/CounterGo/common"
)

const (
	PawnValue = 100
	maxPhase  = 24
	evalScale = 100
)

type EvaluationService struct {
	opening       int
	endgame       int
	phase         int
	whiteFactor   int
	blackFactor   int
	weights       [2 * fSize]int
	features      [fSize]int
	mobilityBonus [1 + 27]int
	pst           pst
}

type pst struct {
	wn, bn, wb, bb, wq, bq, wkOp, bkOp, wkEg, bkEg [64]int
}

func NewEvaluationService() *EvaluationService {
	var srv = &EvaluationService{}
	srv.initPst()
	srv.initMobility()
	srv.initWeights(autoGeneratedWeights)
	return srv
}

func (e *EvaluationService) initPst() {
	var (
		knightLine = [8]int{0, 2, 3, 4, 4, 3, 2, 0}
		bishopLine = [8]int{0, 1, 2, 3, 3, 2, 1, 0}
		kingLine   = [8]int{0, 2, 3, 4, 4, 3, 2, 0}
	)
	for sq := 0; sq < 64; sq++ {
		var f = File(sq)
		var r = Rank(sq)
		e.pst.wn[sq] = knightLine[f] + knightLine[r]
		e.pst.wb[sq] = Min(bishopLine[f], bishopLine[r])
		e.pst.wq[sq] = Min(bishopLine[f], bishopLine[r])
		e.pst.wkOp[sq] = Min(dist[sq][SquareG1], dist[sq][SquareB1])
		e.pst.wkEg[sq] = kingLine[f] + kingLine[r]
	}
	e.pst.initBlack()
}

func (e *EvaluationService) initMobility() {
	for i := range e.mobilityBonus {
		e.mobilityBonus[i] = int(math.Round(20 * math.Sqrt(float64(i))))
	}
}

func (e *EvaluationService) initWeights(weights []int) {
	if len(weights) != len(e.weights) {
		return
	}
	copy(e.weights[:], weights)
}

var pawnPassedBonus = [8]int{0, 0, 0, 2, 6, 12, 21, 0}

const (
	darkSquares  = uint64(0xAA55AA55AA55AA55)
	whiteOutpost = (FileCMask | FileDMask | FileEMask | FileFMask) & (Rank4Mask | Rank5Mask | Rank6Mask)
	blackOutpost = (FileCMask | FileDMask | FileEMask | FileFMask) & (Rank5Mask | Rank4Mask | Rank3Mask)
)

var (
	dist            [64][64]int
	whitePawnSquare [64]uint64
	blackPawnSquare [64]uint64
	kingZone        [64]uint64
)

func (e *EvaluationService) add(feature, value int) {
	e.opening += value * e.weights[2*feature]
	e.endgame += value * e.weights[2*feature+1]
	e.features[feature] += value
}

func (e *EvaluationService) Evaluate(p *Position) int {
	var score = e.evaluateCore(p)
	if !p.WhiteMove {
		score = -score
	}
	return score * PawnValue / e.weights[2*fPawnMaterial+1]
}

type evalEntry struct {
	phase       int
	whiteFactor int
	blackFactor int
	features    []featureEntry
}

type featureEntry struct{ index, value int }

func (entry *evalEntry) Evaluate(weights []int) int {
	var scoreOp, scoreEg int
	for _, f := range entry.features {
		scoreOp += weights[2*f.index] * f.value
		scoreEg += weights[2*f.index+1] * f.value
	}
	var score = (scoreOp*entry.phase + scoreEg*(maxPhase-entry.phase)) / maxPhase
	if score > 0 {
		score /= entry.whiteFactor
	} else {
		score /= entry.blackFactor
	}
	return score
}

func (e *EvaluationService) computeEntry(p *Position) evalEntry {
	for i := range e.features {
		e.features[i] = 0
	}
	e.evaluateCore(p)
	var result = evalEntry{
		phase:       e.phase,
		whiteFactor: e.whiteFactor,
		blackFactor: e.blackFactor,
	}
	for i, v := range e.features {
		if v != 0 {
			result.features = append(result.features, featureEntry{i, v})
		}
	}
	return result
}

const (
	WHITE = iota
	BLACK
)

func (e *EvaluationService) evaluateCore(p *Position) int {
	e.opening = 0
	e.endgame = 0

	var (
		x, b                       uint64
		sq, keySq, bonus           int
		wattackNb, battackNb       int
		wattackCount, battackCount int
	)
	var allPieces = p.White | p.Black
	var wkingSq = FirstOne(p.Kings & p.White)
	var bkingSq = FirstOne(p.Kings & p.Black)

	var pieceCount [2][7]int
	pieceCount[WHITE][Pawn] = PopCount(p.Pawns & p.White)
	pieceCount[BLACK][Pawn] = PopCount(p.Pawns & p.Black)

	e.add(fPawnWeak,
		PopCount(getWhiteWeakPawns(p))-
			PopCount(getBlackWeakPawns(p)))

	e.add(fPawnDoubled,
		PopCount(getIsolatedPawns(p.Pawns&p.White)&getDoubledPawns(p.Pawns&p.White))-
			PopCount(getIsolatedPawns(p.Pawns&p.Black)&getDoubledPawns(p.Pawns&p.Black)))

	e.add(fPawnDuo,
		PopCount(p.Pawns&p.White&(Left(p.Pawns&p.White)|Right(p.Pawns&p.White)))-
			PopCount(p.Pawns&p.Black&(Left(p.Pawns&p.Black)|Right(p.Pawns&p.Black))))

	var attacks [2][7]uint64

	attacks[WHITE][Pawn] = AllWhitePawnAttacks(p.Pawns & p.White)
	attacks[BLACK][Pawn] = AllBlackPawnAttacks(p.Pawns & p.Black)

	e.add(fPawnProtected,
		PopCount(p.Pawns&p.White&attacks[WHITE][Pawn])-
			PopCount(p.Pawns&p.Black&attacks[BLACK][Pawn]))

	e.add(fMinorProtected,
		PopCount((p.Knights|p.Bishops)&p.White&attacks[WHITE][Pawn])-
			PopCount((p.Knights|p.Bishops)&p.Black&attacks[BLACK][Pawn]))

	var wstrongFields = whiteOutpost &^ DownFill(attacks[BLACK][Pawn])
	var bstrongFields = blackOutpost &^ UpFill(attacks[WHITE][Pawn])

	e.add(fKnightOutpost,
		PopCount(p.Knights&p.White&wstrongFields)-
			PopCount(p.Knights&p.Black&bstrongFields))

	var wkingZone = kingZone[wkingSq]
	var bkingZone = kingZone[bkingSq]

	e.add(fPawnBlockedByOwnPiece,
		PopCount(p.Pawns&p.White&^wkingZone&(Rank2Mask|Rank3Mask)&Down(p.White))-
			PopCount(p.Pawns&p.Black&^bkingZone&(Rank7Mask|Rank6Mask)&Up(p.Black)))

	e.add(fPawnRammed,
		PopCount(p.Pawns&p.White&(Rank2Mask|Rank3Mask)&Down(p.Pawns&p.Black))-
			PopCount(p.Pawns&p.Black&(Rank7Mask|Rank6Mask)&Up(p.Pawns&p.White)))

	var wMobilityArea = ^((p.Pawns & p.White) | attacks[BLACK][Pawn])
	var bMobilityArea = ^((p.Pawns & p.Black) | attacks[WHITE][Pawn])

	for x = p.Knights & p.White; x != 0; x &= x - 1 {
		pieceCount[WHITE][Knight]++
		sq = FirstOne(x)
		e.add(fKnightPst, e.pst.wn[sq])
		b = KnightAttacks[sq]
		e.add(fKnightMobility, e.mobilityBonus[PopCount(b&wMobilityArea)])
		attacks[WHITE][Knight] |= b
		if (b & bkingZone & wMobilityArea) != 0 {
			wattackNb++
			wattackCount += PopCount(b & bkingZone & wMobilityArea)
		}
	}

	for x = p.Knights & p.Black; x != 0; x &= x - 1 {
		pieceCount[BLACK][Knight]++
		sq = FirstOne(x)
		e.add(fKnightPst, e.pst.bn[sq])
		b = KnightAttacks[sq]
		e.add(fKnightMobility, -e.mobilityBonus[PopCount(b&bMobilityArea)])
		attacks[BLACK][Knight] |= b
		if (b & wkingZone & bMobilityArea) != 0 {
			battackNb++
			battackCount += PopCount(b & wkingZone & bMobilityArea)
		}
	}

	for x = p.Bishops & p.White; x != 0; x &= x - 1 {
		pieceCount[WHITE][Bishop]++
		sq = FirstOne(x)
		e.add(fBishopPst, e.pst.wb[sq])
		b = BishopAttacks(sq, allPieces)
		e.add(fBishopMobility, e.mobilityBonus[PopCount(b&wMobilityArea)])
		attacks[WHITE][Bishop] |= b
		if (b & bkingZone & wMobilityArea) != 0 {
			wattackNb++
			wattackCount += PopCount(b & bkingZone & wMobilityArea)
		}
		e.add(fBishopRammedPawns, PopCount(sameColorSquares(sq)&p.Pawns&p.White&Down(p.Pawns&p.Black)))
	}

	for x = p.Bishops & p.Black; x != 0; x &= x - 1 {
		pieceCount[BLACK][Bishop]++
		sq = FirstOne(x)
		e.add(fBishopPst, e.pst.bb[sq])
		b = BishopAttacks(sq, allPieces)
		e.add(fBishopMobility, -e.mobilityBonus[PopCount(b&bMobilityArea)])
		attacks[BLACK][Bishop] |= b
		if (b & wkingZone & bMobilityArea) != 0 {
			battackNb++
			battackCount += PopCount(b & wkingZone & bMobilityArea)
		}
		e.add(fBishopRammedPawns, -PopCount(sameColorSquares(sq)&p.Pawns&p.Black&Up(p.Pawns&p.White)))
	}

	for x = p.Rooks & p.White; x != 0; x &= x - 1 {
		pieceCount[WHITE][Rook]++
		sq = FirstOne(x)
		if Rank(sq) == Rank7 &&
			((p.Pawns&p.Black&Rank7Mask) != 0 || Rank(bkingSq) == Rank8) {
			e.add(fRook7th, 1)
		}
		b = RookAttacks(sq, allPieces^(p.Rooks&p.White))
		//b = RookAttacks(sq, allPieces)
		e.add(fRookMobility, e.mobilityBonus[PopCount(b&wMobilityArea)])
		attacks[WHITE][Rook] |= b
		if (b & bkingZone & wMobilityArea) != 0 {
			wattackNb++
			wattackCount += PopCount(b & bkingZone & wMobilityArea)
		}
		b = FileMask[File(sq)]
		if (b & p.Pawns & p.White) == 0 {
			if (b & p.Pawns) == 0 {
				e.add(fRookOpen, 1)
			} else {
				e.add(fRookSemiopen, 1)
			}
		}
	}

	for x = p.Rooks & p.Black; x != 0; x &= x - 1 {
		pieceCount[BLACK][Rook]++
		sq = FirstOne(x)
		if Rank(sq) == Rank2 &&
			((p.Pawns&p.White&Rank2Mask) != 0 || Rank(wkingSq) == Rank1) {
			e.add(fRook7th, -1)
		}
		b = RookAttacks(sq, allPieces^(p.Rooks&p.Black))
		//b = RookAttacks(sq, allPieces)
		e.add(fRookMobility, -e.mobilityBonus[PopCount(b&bMobilityArea)])
		attacks[BLACK][Rook] |= b
		if (b & wkingZone & bMobilityArea) != 0 {
			battackNb++
			battackCount += PopCount(b & wkingZone & bMobilityArea)
		}
		b = FileMask[File(sq)]
		if (b & p.Pawns & p.Black) == 0 {
			if (b & p.Pawns) == 0 {
				e.add(fRookOpen, -1)
			} else {
				e.add(fRookSemiopen, -1)
			}
		}
	}

	for x = p.Queens & p.White; x != 0; x &= x - 1 {
		pieceCount[WHITE][Queen]++
		sq = FirstOne(x)
		e.add(fQueenPst, e.pst.wq[sq])
		b = QueenAttacks(sq, allPieces)
		e.add(fQueenMobility, e.mobilityBonus[PopCount(b&wMobilityArea)])
		attacks[WHITE][Queen] |= b
		if (b & bkingZone & wMobilityArea) != 0 {
			wattackNb++
			wattackCount += PopCount(b & bkingZone & wMobilityArea)
		}
	}

	for x = p.Queens & p.Black; x != 0; x &= x - 1 {
		pieceCount[BLACK][Queen]++
		sq = FirstOne(x)
		e.add(fQueenPst, e.pst.bq[sq])
		b = QueenAttacks(sq, allPieces)
		e.add(fQueenMobility, -e.mobilityBonus[PopCount(b&bMobilityArea)])
		attacks[BLACK][Queen] |= b
		if (b & wkingZone & bMobilityArea) != 0 {
			battackNb++
			battackCount += PopCount(b & wkingZone & bMobilityArea)
		}
	}

	attacks[WHITE][King] = KingAttacks[wkingSq]
	attacks[BLACK][King] = KingAttacks[bkingSq]

	/*var wattacks = attacks[WHITE][Pawn] |
		attacks[WHITE][Knight] |
		attacks[WHITE][Bishop] |
		attacks[WHITE][Rook] |
		attacks[WHITE][Queen] |
		attacks[WHITE][King]

	var battacks = attacks[BLACK][Pawn] |
		attacks[BLACK][Knight] |
		attacks[BLACK][Bishop] |
		attacks[BLACK][Rook] |
		attacks[BLACK][Queen] |
		attacks[BLACK][King]*/

	// Threats

	e.add(fThreatPawn,
		PopCount(attacks[WHITE][Pawn]&p.Black&^(p.Pawns|p.Queens))-
			PopCount(attacks[BLACK][Pawn]&p.White&^(p.Pawns|p.Queens)))

	e.add(fThreatForPawn,
		PopCount((attacks[WHITE][Rook]|attacks[WHITE][King])&p.Black&p.Pawns&^attacks[BLACK][Pawn])-
			PopCount((attacks[BLACK][Rook]|attacks[BLACK][King])&p.White&p.Pawns&^attacks[WHITE][Pawn]))

	e.add(fThreatPiece,
		PopCount((attacks[WHITE][Knight]|attacks[WHITE][Bishop]|attacks[WHITE][Rook])&p.Black&(p.Knights|p.Bishops|p.Rooks))-
			PopCount((attacks[BLACK][Knight]|attacks[BLACK][Bishop]|attacks[BLACK][Rook])&p.White&(p.Knights|p.Bishops|p.Rooks)))

	e.add(fThreatPieceForQueen,
		PopCount((attacks[WHITE][Pawn]|attacks[WHITE][Knight]|attacks[WHITE][Bishop]|attacks[WHITE][Rook])&p.Black&p.Queens)-
			PopCount((attacks[BLACK][Pawn]|attacks[BLACK][Knight]|attacks[BLACK][Bishop]|attacks[BLACK][Rook])&p.White&p.Queens))

	var whiteForce = pieceCount[WHITE][Knight] + pieceCount[WHITE][Bishop] +
		2*pieceCount[WHITE][Rook] +
		4*pieceCount[WHITE][Queen]
	var blackForce = pieceCount[BLACK][Knight] + pieceCount[BLACK][Bishop] +
		2*pieceCount[BLACK][Rook] +
		4*pieceCount[BLACK][Queen]

	for x = getWhitePassedPawns(p); x != 0; x &= x - 1 {
		sq = FirstOne(x)
		bonus = pawnPassedBonus[Rank(sq)]
		e.add(fPawnPassed, bonus)
		keySq = sq + 8
		e.add(fPawnPassedOppKing, bonus*dist[keySq][bkingSq])
		e.add(fPawnPassedOwnKing, bonus*dist[keySq][wkingSq])
		if (SquareMask[keySq] & p.Black) == 0 {
			e.add(fPawnPassedFree, bonus)
		}
		/*if (UpFill(SquareMask[keySq]) & (p.Black | (battacks &^ wattacks))) == 0 {
			e.add(fPawnPassedSafeAdvance, bonus)
		}*/

		if blackForce == 0 {
			var f1 = sq
			if !p.WhiteMove {
				f1 -= 8
			}
			if (whitePawnSquare[f1] & p.Kings & p.Black) == 0 {
				e.add(fPawnPassedSquare, Rank(f1)-Rank1)
				//pawnScore.endgame += 200 * Rank(f1) / Rank7
			}
		}
	}

	for x = getBlackPassedPawns(p); x != 0; x &= x - 1 {
		sq = FirstOne(x)
		bonus = -pawnPassedBonus[Rank(FlipSquare(sq))]
		e.add(fPawnPassed, bonus)
		keySq = sq - 8
		e.add(fPawnPassedOppKing, bonus*dist[keySq][wkingSq])
		e.add(fPawnPassedOwnKing, bonus*dist[keySq][bkingSq])
		if (SquareMask[keySq] & p.White) == 0 {
			e.add(fPawnPassedFree, bonus)
		}
		/*if (DownFill(SquareMask[keySq]) & (p.White | (wattacks &^ battacks))) == 0 {
			e.add(fPawnPassedSafeAdvance, bonus)
		}*/

		if whiteForce == 0 {
			var f1 = sq
			if p.WhiteMove {
				f1 += 8
			}
			if (blackPawnSquare[f1] & p.Kings & p.White) == 0 {
				e.add(fPawnPassedSquare, Rank(f1)-Rank8)
				//pawnScore.endgame -= 200 * (Rank8 - Rank(f1)) / Rank7
			}
		}
	}

	e.add(fKingCastlingPst, e.pst.wkOp[wkingSq]+e.pst.bkOp[bkingSq])
	e.add(fKingCenterPst, e.pst.wkEg[wkingSq]+e.pst.bkEg[bkingSq])
	e.add(fKingShelter,
		shelterWKingSquare(p, wkingSq)-
			shelterBKingSquare(p, bkingSq))

	if wattackNb >= 2 {
		e.add(fKingAttack, wattackCount)
	}
	if battackNb >= 2 {
		e.add(fKingAttack, -battackCount)
	}

	if !p.IsCheck() {
		if p.WhiteMove {
			e.add(fSideToMove, 1)
		} else {
			e.add(fSideToMove, -1)
		}
	}

	e.add(fPawnMaterial, pieceCount[WHITE][Pawn]-pieceCount[BLACK][Pawn])
	e.add(fKnightMaterial, pieceCount[WHITE][Knight]-pieceCount[BLACK][Knight])
	e.add(fBishopMaterial, pieceCount[WHITE][Bishop]-pieceCount[BLACK][Bishop])
	e.add(fRookMaterial, pieceCount[WHITE][Rook]-pieceCount[BLACK][Rook])
	e.add(fQueenMaterial, pieceCount[WHITE][Queen]-pieceCount[BLACK][Queen])
	if pieceCount[WHITE][Bishop] >= 2 {
		e.add(fBishopPairMaterial, 1)
	}
	if pieceCount[BLACK][Bishop] >= 2 {
		e.add(fBishopPairMaterial, -1)
	}

	var phase = whiteForce + blackForce
	if phase > maxPhase {
		phase = maxPhase
	}
	var result = (e.opening*phase + e.endgame*(maxPhase-phase)) / maxPhase

	e.phase = phase
	var ocb = whiteForce == 1 && blackForce == 1 &&
		(p.Bishops&darkSquares) != 0 && (p.Bishops & ^darkSquares) != 0
	e.whiteFactor = computeFactor(&pieceCount[WHITE], &pieceCount[BLACK], whiteForce, blackForce, ocb)
	e.blackFactor = computeFactor(&pieceCount[BLACK], &pieceCount[WHITE], blackForce, whiteForce, ocb)

	if result > 0 {
		result /= e.whiteFactor
	} else {
		result /= e.blackFactor
	}

	return result
}

func computeFactor(us, them *[7]int, forceUs, forceThem int, ocb bool) int {
	if forceUs >= 6 {
		return 1
	}
	if us[Pawn] == 0 {
		if forceUs <= 1 {
			return 16
		}
		if forceUs == 2 && us[Knight] == 2 && them[Pawn] == 0 {
			return 16
		}
		if forceUs-forceThem <= 1 {
			return 4
		}
	} else if us[Pawn] == 1 {
		if forceUs <= 1 && them[Knight]+them[Bishop] != 0 {
			return 8
		}
		if forceUs == forceThem && them[Knight]+them[Bishop] != 0 {
			return 2
		}
	} else if ocb && us[Pawn]-them[Pawn] <= 2 {
		return 2
	}
	return 1
}

func getDoubledPawns(pawns uint64) uint64 {
	return DownFill(Down(pawns)) & pawns
}

func getIsolatedPawns(pawns uint64) uint64 {
	return ^FileFill(Left(pawns)|Right(pawns)) & pawns
}

func getWhitePassedPawns(p *Position) uint64 {
	return p.Pawns & p.White &^
		DownFill(Down(Left(p.Pawns&p.Black)|p.Pawns|Right(p.Pawns&p.Black)))
}

func getBlackPassedPawns(p *Position) uint64 {
	return p.Pawns & p.Black &^
		UpFill(Up(Left(p.Pawns&p.White)|p.Pawns|Right(p.Pawns&p.White)))
}

func getWhiteWeakPawns(p *Position) uint64 {
	var pawns = p.Pawns & p.White
	var supported = UpFill(Left(pawns) | Right(pawns))
	var weak = uint64(0)
	weak |= getIsolatedPawns(pawns)
	weak |= (Rank2Mask | Rank3Mask | Rank4Mask) & Down(AllBlackPawnAttacks(p.Pawns&p.Black)) &^ supported
	return pawns & weak

}

func getBlackWeakPawns(p *Position) uint64 {
	var pawns = p.Pawns & p.Black
	var supported = DownFill(Left(pawns) | Right(pawns))
	var weak = uint64(0)
	weak |= getIsolatedPawns(pawns)
	weak |= (Rank7Mask | Rank6Mask | Rank5Mask) & Up(AllWhitePawnAttacks(p.Pawns&p.White)) &^ supported
	return pawns & weak
}

func shelterWKingSquare(p *Position, square int) int {
	var file = File(square)
	if file <= FileC {
		file = FileB
	} else if file >= FileF {
		file = FileG
	}
	var penalty = 0
	for i := 0; i < 3; i++ {
		var mask = FileMask[file+i-1] & p.White & p.Pawns
		if (mask & Rank2Mask) == 0 {
			penalty++
			if (mask & Rank3Mask) == 0 {
				penalty++
				if mask == 0 {
					penalty++
				}
			}
		}
	}
	if penalty == 1 {
		penalty = 0
	}
	return penalty
}

func shelterBKingSquare(p *Position, square int) int {
	var file = File(square)
	if file <= FileC {
		file = FileB
	} else if file >= FileF {
		file = FileG
	}
	var penalty = 0
	for i := 0; i < 3; i++ {
		var mask = FileMask[file+i-1] & p.Black & p.Pawns
		if (mask & Rank7Mask) == 0 {
			penalty++
			if (mask & Rank6Mask) == 0 {
				penalty++
				if mask == 0 {
					penalty++
				}
			}
		}
	}
	if penalty == 1 {
		penalty = 0
	}
	return penalty
}

func (pst *pst) initBlack() {
	for sq := 0; sq < 64; sq++ {
		var flipSq = FlipSquare(sq)
		pst.bn[sq] = -pst.wn[flipSq]
		pst.bb[sq] = -pst.wb[flipSq]
		pst.bq[sq] = -pst.wq[flipSq]
		pst.bkOp[sq] = -pst.wkOp[flipSq]
		pst.bkEg[sq] = -pst.wkEg[flipSq]
	}
}

func sameColorSquares(sq int) uint64 {
	if IsDarkSquare(sq) {
		return darkSquares
	}
	return ^darkSquares
}

func init() {
	for i := 0; i < 64; i++ {
		for j := 0; j < 64; j++ {
			dist[i][j] = SquareDistance(i, j)
		}
	}
	for sq := 0; sq < 64; sq++ {
		var x = UpFill(SquareMask[sq])
		for j := 0; j < Rank(FlipSquare(sq)); j++ {
			x |= Left(x) | Right(x)
		}
		whitePawnSquare[sq] = x
	}
	for sq := 0; sq < 64; sq++ {
		var x = DownFill(SquareMask[sq])
		for j := 0; j < Rank(sq); j++ {
			x |= Left(x) | Right(x)
		}
		blackPawnSquare[sq] = x
	}
	for sq := range kingZone {
		kingZone[sq] = SquareMask[sq] | KingAttacks[sq]
	}
}
