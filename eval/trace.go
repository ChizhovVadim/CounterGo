package eval

import (
	"fmt"
	"os"
	"text/tabwriter"

	"github.com/ChizhovVadim/CounterGo/common"
)

var featureNames = initFeatureNames()

func initFeatureNames() []string {
	var t = make([]string, fSize)
	t[fPawnMaterial] = "fPawnMaterial"
	t[fKnightMaterial] = "fKnightMaterial"
	t[fBishopMaterial] = "fBishopMaterial"
	t[fRookMaterial] = "fRookMaterial"
	t[fQueenMaterial] = "fQueenMaterial"
	t[fBishopPairMaterial] = "fBishopPairMaterial"
	t[fPawnWeak] = "fPawnWeak"
	t[fPawnDoubled] = "fPawnDoubled"
	t[fPawnDuo] = "fPawnDuo"
	t[fPawnProtected] = "fPawnProtected"
	t[fPawnPassed] = "fPawnPassed"
	t[fPawnPassedFree] = "fPawnPassedFree"
	//t[fPawnPassedSafeAdvance] = "fPawnPassedSafeAdvance"
	t[fPawnPassedOppKing] = "fPawnPassedOppKing"
	t[fPawnPassedOwnKing] = "fPawnPassedOwnKing"
	t[fPawnPassedSquare] = "fPawnPassedSquare"
	t[fThreatPawn] = "fThreatPawn"
	t[fThreatForPawn] = "fThreatForPawn"
	t[fThreatPiece] = "fThreatPiece"
	t[fThreatPieceForQueen] = "fThreatPieceForQueen"
	t[fKnightPst] = "fKnightPst"
	t[fBishopPst] = "fBishopPst"
	t[fQueenPst] = "fQueenPst"
	t[fKingCastlingPst] = "fKingCastlingPst"
	t[fKingCenterPst] = "fKingCenterPst"
	t[fKnightMobility] = "fKnightMobility"
	t[fBishopMobility] = "fBishopMobility"
	t[fRookMobility] = "fRookMobility"
	t[fQueenMobility] = "fQueenMobility"
	t[fRook7th] = "fRook7th"
	t[fRookOpen] = "fRookOpen"
	t[fRookSemiopen] = "fRookSemiopen"
	t[fKingShelter] = "fKingShelter"
	t[fKingAttack] = "fKingAttack"
	t[fBishopRammedPawns] = "fBishopRammedPawns"
	t[fMinorProtected] = "fMinorProtected"
	t[fKnightOutpost] = "fKnightOutpost"
	t[fPawnBlockedByOwnPiece] = "fPawnBlockedByOwnPiece"
	t[fPawnRammed] = "fPawnRammed"
	t[fSideToMove] = "fSideToMove"
	return t
}

func PrintWeights() {
	var w = tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', tabwriter.AlignRight)
	fmt.Fprintf(w, "Feature\tOpening\tEndgame\t\n")
	for featureIndex := range featureNames {
		fmt.Fprintf(w, "%v\t%v\t%v\t\n",
			featureNames[featureIndex],
			autoGeneratedWeights[2*featureIndex],
			autoGeneratedWeights[2*featureIndex+1])
	}
	w.Flush()
}

func (e *EvaluationService) Trace(p *common.Position) {
	var pawnEg = e.weights[2*fPawnMaterial+1]
	var entry = e.computeEntry(p)
	var w = tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', tabwriter.AlignRight)
	fmt.Fprintf(w, "Feature\tScore\t\n")
	for _, f := range entry.features {
		var scoreOp = e.weights[2*f.index] * f.value
		var scoreEg = e.weights[2*f.index+1] * f.value
		var score = (entry.phase*scoreOp + (maxPhase-entry.phase)*scoreEg) / maxPhase
		score = score * PawnValue / pawnEg
		fmt.Fprintf(w, "%v\t%v\t\n",
			featureNames[f.index], score)
	}
	w.Flush()
	var score = entry.Evaluate(e.weights[:]) * PawnValue / pawnEg
	fmt.Println("Score:", score)
}
