package tuner

import (
	"fmt"
	"log"
	"math"
	"runtime"
	"sync"
	"sync/atomic"

	"github.com/ChizhovVadim/CounterGo/common"
)

type Evaluator interface {
	Evaluate(p *common.Position) int
	Apply(weights []int) []int
}

type tuneEntry struct {
	score    float64
	position common.Position
}

// Finds weights for evaluation function
//https://www.chessprogramming.org/Texel%27s_Tuning_Method
func RunTune(filename string, evalBuilder func() Evaluator) error {
	log.Println("Tune started.")
	defer log.Println("Tune finished.")

	var entries = make(chan learnEntry, 128)
	go func() {
		defer close(entries)
		var err = readLearn(filename, entries)
		if err != nil {
			log.Println(err)
			return
		}
	}()

	var samples []tuneEntry
	for entry := range entries {
		var p, err = common.NewPositionFromFEN(entry.fen)
		if err != nil {
			return err
		}
		//TODO if IsQuiet?
		// whatever do not use evaluate when in check
		if p.IsCheck() {
			continue
		}
		var tuneEntry = tuneEntry{
			score:    entry.score,
			position: p,
		}
		samples = append(samples, tuneEntry)
	}
	log.Printf("Loaded %v entries.\n", len(samples))

	var errF = newErrf(samples, evalBuilder)

	var evalService = evalBuilder()
	var weights = evalService.Apply(nil)
	coordinateDescent(weights, errF)
	var er = errF(weights)
	fmt.Printf("// Error: %.6f\n", er)
	fmt.Printf("var autoGeneratedWeights = %#v\n", weights)

	return nil
}

func newErrf(samples []tuneEntry, evalBuilder func() Evaluator) func(w []int) float64 {
	var numCPU = runtime.NumCPU()
	var sums = make([]float64, numCPU)
	var evalServices = make([]Evaluator, numCPU)
	for i := range evalServices {
		evalServices[i] = evalBuilder()
	}

	return func(w []int) float64 {
		var wg = &sync.WaitGroup{}
		var index = int32(-1)
		for thread := 0; thread < numCPU; thread++ {
			wg.Add(1)
			go func(thread int) {
				var evalService = evalServices[thread]
				evalService.Apply(w)
				var localSum = 0.0
				for {
					var i = int(atomic.AddInt32(&index, 1))
					if i >= len(samples) {
						break
					}
					var entry = &samples[i]
					var eval = evalService.Evaluate(&entry.position)
					if !entry.position.WhiteMove {
						eval = -eval
					}
					var diff = entry.score - sigmoid(float64(eval))
					localSum += diff * diff
				}
				sums[thread] = localSum
				wg.Done()
			}(thread)
		}
		wg.Wait()
		var sum = 0.0
		for _, item := range sums {
			sum += item
		}
		return sum / float64(len(samples))
	}
}

func sigmoid(s float64) float64 {
	return 1.0 / (1.0 + math.Exp(-s/135))
}

func coordinateDescent(weights []int, errf func([]int) float64) {
	var bestE = errf(weights)
	var stepRatio = 2.0
	for iter := 0; iter < 34; iter++ {
		log.Printf("Iteration: %v Error: %.6f Params: %#v\n",
			iter, bestE, weights)
		if iter > 0 {
			stepRatio *= 0.85
		}
		for weightIndex := range weights {
			var oldValue = weights[weightIndex]
			var delta = max(1, int(math.Round(stepRatio*float64(abs(oldValue)))))
			for dir := 0; dir <= 1; dir++ {
				var step = delta
				if dir == 1 {
					step = -step
				}
				var curValue = weights[weightIndex]
				weights[weightIndex] = oldValue + step
				var curE = errf(weights)
				if curE < bestE {
					bestE = curE
					break
				} else {
					weights[weightIndex] = curValue
				}
			}
		}
	}
}

func abs(v int) int {
	if v < 0 {
		return -v
	}
	return v
}

func max(l, r int) int {
	if l > r {
		return l
	}
	return r
}
