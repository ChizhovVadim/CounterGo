package eval

import (
	"bufio"
	"fmt"
	"log"
	"os"
	"strings"
)

type LearnEntry struct {
	Fen   string
	Score float64
}

const LearnFilePath = "/home/vadim/chess/tuner/quiet-labeled.epd"

func ReadLearn(filePath string, learnEntries chan<- LearnEntry) error {
	file, err := os.Open(filePath)
	if err != nil {
		return err
	}
	defer file.Close()
	var scanner = bufio.NewScanner(file)
	for scanner.Scan() {
		var line = scanner.Text()
		var entry, err = parseLearnEntry(line)
		if err != nil {
			return err
		}
		learnEntries <- entry
	}
	return scanner.Err()
}

func parseLearnEntry(s string) (LearnEntry, error) {
	var index = strings.Index(s, "\"")
	if index < 0 {
		return LearnEntry{}, fmt.Errorf("parseLearnEntry failed %v", s)
	}
	var fen = s[:index]
	var score float64
	var strScore = s[index+1:]
	if strings.HasPrefix(strScore, "1/2-1/2") {
		score = 0.5
	} else if strings.HasPrefix(strScore, "1-0") {
		score = 1.0
	} else if strings.HasPrefix(strScore, "0-1") {
		score = 0.0
	} else {
		return LearnEntry{}, fmt.Errorf("parseLearnEntry failed %v", s)
	}
	return LearnEntry{fen, score}, nil
}

type TuneBuilder interface {
	AddSample(fen string, score float64) error
	GetStartingWeights() []int
	ComputeError(weights []int, lambda float64) float64
}

func RunTuning(tuneBuilder TuneBuilder) {
	log.Println("Tune started.")
	var entries = make(chan LearnEntry, 128)
	go func() {
		defer close(entries)
		var err = ReadLearn(LearnFilePath, entries)
		if err != nil {
			log.Println(err)
			return
		}
	}()
	var count = 0
	for entry := range entries {
		var err = tuneBuilder.AddSample(entry.Fen, entry.Score)
		if err != nil {
			log.Println(err)
			return
		}
		count++
	}
	log.Printf("Loaded %v entries.\n", count)
	const lambda = 1e-6
	var weights = tuneEvalService(tuneBuilder, lambda)
	var total = tuneBuilder.ComputeError(weights, lambda)
	var er = tuneBuilder.ComputeError(weights, 0)
	fmt.Printf("// Error: %.6f\n", er)
	fmt.Printf("// Regularization: %.6f\n", total-er)
	fmt.Printf("// Total: %.6f\n", total)
	fmt.Printf("var autoGeneratedWeights = %#v\n", weights)
	log.Println("Tune finished.")
}

//https://www.chessprogramming.org/Texel%27s_Tuning_Method
func tuneEvalService(tuneBuilder TuneBuilder, lambda float64) []int {
	var params = tuneBuilder.GetStartingWeights()
	var bestE = tuneBuilder.ComputeError(params, lambda)
	for iter := 0; iter < 30; iter++ {
		log.Printf("Iteration: %v Error: %.6f Params: %#v\n",
			iter, bestE, params)
		var improved = false
		for paramIndex := range params {
			var oldValue = params[paramIndex]
			var bestValue = oldValue
			for step := 1; step <= 64; step *= 2 {
				params[paramIndex] = bestValue + step
				var newE = tuneBuilder.ComputeError(params, lambda)
				if newE < bestE {
					bestValue = params[paramIndex]
					bestE = newE
					improved = true
				} else {
					params[paramIndex] = bestValue
					if newE > bestE {
						break
					}
				}
			}
			if oldValue == bestValue {
				for step := 1; step <= 64; step *= 2 {
					params[paramIndex] = bestValue - step
					var newE = tuneBuilder.ComputeError(params, lambda)
					if newE < bestE {
						bestValue = params[paramIndex]
						bestE = newE
						improved = true
					} else {
						params[paramIndex] = bestValue
						if newE > bestE {
							break
						}
					}
				}
			}
		}
		if !improved {
			break
		}
	}
	return params
}
