package eval

import (
	. "github.com/ChizhovVadim/CounterGo/common"
)

const (
	sideWhite = 0
	sideBlack = 1
)

type Weights struct {
	PawnMaterial          Score
	KnightMaterial        Score
	BishopMaterial        Score
	RookMaterial          Score
	QueenMaterial         Score
	BishopPairMaterial    Score
	PawnWeak              Score
	PawnDoubled           Score
	PawnDuo               Score
	PawnProtected         Score
	PawnPassed            [8]Score
	PawnPassedFree        [8]Score
	PawnPassedOppKing     [8]Score
	PawnPassedOwnKing     [8]Score
	PawnPassedSquare      Score
	ThreatPawn            Score
	ThreatForPawn         Score
	ThreatPiece           Score
	ThreatPieceForQueen   Score
	Rook7th               Score
	RookOpen              Score
	RookSemiopen          Score
	KingShelter           Score
	KingAttack            [4]Score
	KingQueenTropism      Score
	BishopRammedPawns     Score
	MinorProtected        Score
	KnightOutpost         Score
	PawnBlockedByOwnPiece Score
	PawnRammed            Score
	Tempo                 Score
	KnightMobility        [9]Score
	BishopMobility        [14]Score
	RookMobility          [15]Score
	QueenMobility         [28]Score
	PST                   [2][8][64]Score `json:"-"`
}

func (w *Weights) init() {
	// Error: 0.055018
	var autoGeneratedWeights = []int{88, 387, 332, 417, 351, 568, 616, 1413, 1188, 51, 53, 31, -8, 2, -7, -1, 1, -3, -2, -9, -3, 1, -3, 0, 7, 1, 10, -11, -7, -3, -8, -5, -4, -6, 3, -13, 5, -10, 4, 4, -7, 15, -8, 4, 21, 10, 17, 10, 7, 24, -1, 37, 23, 24, 29, 59, 13, 49, -1, 30, 33, 54, 40, 48, 38, 108, 38, 129, -5, -3, -1, 0, -1, -4, 1, 9, -11, 25, 2, 26, 6, 33, 17, -2, 2, 8, 8, 20, 4, 24, 21, 29, 22, 34, -2, -10, 6, -99, 5, 6, 20, 27, 18, 24, 23, 11, 33, 4, 14, 20, 8, 19, 12, 2, 17, -1, 20, 17, 8, -37, 17, -23, 4, -9, 20, -12, 23, 5, 18, 10, 16, 15, 10, -3, 20, 3, 18, -2, 28, 7, 27, 11, 22, 20, 18, 19, 34, 21, 25, 14, 19, 9, 22, 14, 19, 43, 5, 30, 6, 6, 21, -22, 47, -40, 53, -12, 34, -59, 59, -1, 37, 1, -23, 10, -2, -45, 17, -2, 9, 16, -44, -17, -1, -11, 10, -42, 21, -5, 27, 66, 23, 45, 18, -11, -15, 11, 13, 12, 12, 9, 15, 9, 40, 59, 13, -5, 20, 27, 18, 55, 0, -15, -6, -3, -18, 8, 4, 18, 13, 1, 9, 44, -2, 10, 7, 13, 46, 158, -15, -18, -7, -13, 8, 22, 30, -4, -18, 6, 13, 5, 10, 35, 35, 22}
	w.Apply(autoGeneratedWeights)
}

func (w *Weights) Apply(weights []int) []int {
	var wh = &weightHolder{weights: weights, index: 0}

	w.PawnMaterial = Score{wh.withDefault(100).next(), 100}
	w.KnightMaterial = Score{wh.withDefault(325).next(), wh.withDefault(325).next()}
	w.BishopMaterial = Score{wh.withDefault(325).next(), wh.withDefault(325).next()}
	w.RookMaterial = Score{wh.withDefault(500).next(), wh.withDefault(500).next()}
	w.QueenMaterial = Score{wh.withDefault(1000).next(), wh.withDefault(1000).next()}
	w.BishopPairMaterial = Score{wh.withDefault(50).next(), wh.withDefault(50).next()}

	initPst32(w.PST[sideWhite][Pawn][:], wh)
	initPst12(w.PST[sideWhite][Knight][:], wh)
	initPst12(w.PST[sideWhite][Bishop][:], wh)
	initPst12(w.PST[sideWhite][Rook][:], wh)
	initPst12(w.PST[sideWhite][Queen][:], wh)
	initPst12(w.PST[sideWhite][King][:], wh)
	initPstBlack(w)

	initGeomProgr(w.KnightMobility[:], wh.nextScore())
	initGeomProgr(w.BishopMobility[:], wh.nextScore())
	initGeomProgr(w.RookMobility[:], wh.nextScore())
	initGeomProgr(w.QueenMobility[:], wh.nextScore())

	w.ThreatPawn = wh.nextScore()
	w.ThreatForPawn = wh.nextScore()
	w.ThreatPiece = wh.nextScore()
	w.ThreatPieceForQueen = wh.nextScore()

	w.PawnWeak = wh.nextScore()
	w.PawnDoubled = wh.nextScore()
	w.PawnDuo = wh.nextScore()
	w.PawnProtected = wh.nextScore()
	w.Rook7th = wh.nextScore()
	w.RookOpen = wh.nextScore()
	w.RookSemiopen = wh.nextScore()
	w.KingShelter = Score{wh.next(), 0}

	for i := 2; i < len(w.KingAttack); i++ {
		w.KingAttack[i] = Score{wh.next(), 0}
	}

	w.KingQueenTropism = wh.nextScore()
	w.BishopRammedPawns = wh.nextScore()
	w.MinorProtected = wh.nextScore()
	w.KnightOutpost = wh.nextScore()
	w.PawnBlockedByOwnPiece = wh.nextScore()
	w.PawnRammed = wh.nextScore()

	var pawnPassed = wh.nextScore()
	var pawnPassedFree = wh.next()
	var pawnPassedOppKing = wh.next()
	var pawnPassedBonus = [8]float64{0, 0.1, 0.13, 0.16, 0.28, 0.68, 1.0, 0}
	//var pawnPassedBonus = [8]int{0, 0, 0, 2, 6, 12, 21, 0}
	var pawnPassedStepPrice = mean(pawnPassedBonus[1:7])
	for i := 0; i < 8; i++ {
		var r = pawnPassedBonus[i] / pawnPassedStepPrice
		w.PawnPassed[i] = makeScore(float64(pawnPassed.Mg)*r,
			float64(pawnPassed.Eg)*r)
		if i >= Rank4 {
			w.PawnPassedFree[i] = makeScore(0,
				float64(pawnPassedFree)*r)
			w.PawnPassedOppKing[i] = makeScore(0,
				float64(pawnPassedOppKing)*r)
			w.PawnPassedOwnKing[i] = makeScore(0,
				float64(pawnPassedOppKing)*r/-2.5)
		}
	}
	w.PawnPassedSquare = Score{0, 33}
	w.Tempo = Score{8, 8}

	return wh.weights
}

func centerScores(source []Score) {
	var s Score
	for _, x := range source {
		s.add(x)
	}
	var center = Score{s.Mg / len(source), s.Eg / len(source)}
	for i := range source {
		source[i].sub(center)
	}
}

func mean(source []float64) float64 {
	var sum = 0.0
	var count = 0
	for _, x := range source {
		sum += x
		count++
	}
	return sum / float64(count)
}

func initGeomProgr(source []Score, weight Score) {
	const b1 = 1.0
	const q = 0.9

	var bi = b1
	var sum = 0.0

	for i := range source {
		if i > 0 {
			sum += bi
			bi *= q
		}
		source[i] = makeScore(sum*float64(weight.Mg), sum*float64(weight.Eg))
	}

	centerScores(source)
}

func initPst32(pst []Score, wh *weightHolder) {
	var center [32]Score
	wh.initScores(center[:])
	for sq := 0; sq < 64; sq++ {
		pst[sq] = center[toSq32(sq)]
	}
}

func initPst12(pst []Score, wh *weightHolder) {
	var fileCenter [4]Score
	var rankCenter [8]Score
	wh.initScores(fileCenter[:])
	wh.initScores(rankCenter[:])
	for sq := 0; sq < 64; sq++ {
		pst[sq] = fileCenter[file4(sq)]
		pst[sq].add(rankCenter[Rank(sq)])
	}
}

func initPstBlack(w *Weights) {
	for pieceType := Pawn; pieceType <= King; pieceType++ {
		for sq := 0; sq < 64; sq++ {
			w.PST[sideBlack][pieceType][sq] = negScore(w.PST[sideWhite][pieceType][FlipSquare(sq)])
		}
	}
}

func file4(sq int) int {
	var f = File(sq)
	if f >= FileE {
		f = FileH - f
	}
	return f
}

func toSq32(sq int) int {
	return 4*Rank(sq) + file4(sq)
}
